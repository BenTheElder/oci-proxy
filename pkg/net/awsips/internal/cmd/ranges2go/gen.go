/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"io"
	"sort"
)

const fileHeader = `/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// File generated by pkg/net/awsips/internal/cmd/ranges2go/run.sh DO NOT EDIT

package awsips


`

// TODO: ipv6
func generateRangesGo(w io.Writer, data *IPRangesJson) error {
	// collect mapping of regions to prefix
	regionToPrefixes := map[string][]string{}
	for _, prefix := range data.Prefixes {
		region := prefix.Region
		ipPrefix := prefix.IPPrefix
		regionToPrefixes[region] = append(regionToPrefixes[region], ipPrefix)
	}

	// flatten
	numPrefixes := 0
	for region := range regionToPrefixes {
		// this approach allows us to produce consistent generated results
		// since the ip ranges will be ordered
		sort.Strings(regionToPrefixes[region])
		regionToPrefixes[region] = dedupeSortedStrings(regionToPrefixes[region])
		numPrefixes += len(regionToPrefixes[region])
	}

	// get flattened ranges across all regions
	allPrefixes := make([]string, 0, numPrefixes)
	for region := range regionToPrefixes {
		allPrefixes = append(allPrefixes, regionToPrefixes[region]...)
	}
	sort.Strings(allPrefixes)
	allPrefixes = dedupeSortedStrings(allPrefixes)

	// generate source file
	if _, err := io.WriteString(w, fileHeader); err != nil {
		return err
	}

	if _, err := io.WriteString(w, "var rawRanges = []string{\n"); err != nil {
		return err
	}
	for _, prefix := range allPrefixes {
		if _, err := io.WriteString(w, "\t`"); err != nil {
			return err
		}
		if _, err := io.WriteString(w, prefix); err != nil {
			return err
		}
		if _, err := io.WriteString(w, "`,\n"); err != nil {
			return err
		}
	}
	if _, err := io.WriteString(w, "}"); err != nil {
		return err
	}

	return nil
}

func dedupeSortedStrings(s []string) []string {
	l := len(s)
	// nothing to do for <= 1 string
	if l <= 1 {
		return s
	}
	// for 1..len(s) if previous entry does not match, keep current
	j := 0
	for i := 1; i < l; i++ {
		if s[i] != s[i-1] {
			s[j] = s[i]
			j++
		}
	}
	return s[0:j]
}
